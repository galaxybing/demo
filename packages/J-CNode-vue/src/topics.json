{
  "success": true,
  "data": [
    {
      "id": "5a2403226190c8912ebaceeb",
      "author_id": "4f447c2f0a8abae26e01b27d",
      "tab": "share",
      "content": "<div class=\"markdown-text\"><p><img src=\"//dn-cnode.qbox.me/FhSNYCv6Ab9wzT6aUSfKLa0GtP4w\" alt=\"image.png\"></p>\n<blockquote>\n<p>原文地址：知乎专栏 <a href=\"https://zhuanlan.zhihu.com/p/31640541\">https://zhuanlan.zhihu.com/p/31640541</a></p>\n</blockquote>\n<p>给大家介绍下，Egg 2.0 正式版，今天 12.3 冒泡啦，距 3.21 的 <a href=\"https://zhuanlan.zhihu.com/p/25860846\">Egg 1.0 版本</a> 时隔 8 个月。</p>\n<p><img src=\"//dn-cnode.qbox.me/FrC_ZbrhyLkhVIquPOsMqPhvqsHX\" alt=\"image.png\"></p>\n<blockquote>\n<p><a href=\"https://eggjs.org/\">Egg</a> 是阿里 Node.js 的核心基础框架，面向『企业级的 Web 基础框架』这个领域，提供了「微内核 + 插件机制 + 框架定制能力」，完美达成生态共建和差异化定制的平衡点。<br>\n既适合个人小项目快速开发，也适合团队架构师基于自身的技术架构在 Egg 基础上扩展出适合特定团队业务场景的框架。<br>\n它沉淀自阿里在各行各业不同领域的大规模工程实践经验，稳定支撑了多年天猫双11大促，顶级流量压力。</p>\n</blockquote>\n<h2>2.0 特性</h2>\n<ul>\n<li>基于 Koa 2.x\n<ul>\n<li>异步解决方案直接基于 Async Function 。</li>\n<li>去除 co 兼容后<a href=\"https://github.com/eggjs/egg/wiki/co-vs-async\">堆栈信息更清晰</a>。</li>\n</ul>\n</li>\n<li>框架层优化带来 <a href=\"https://eggjs.github.io/benchmark/plot/\">30% 左右的性能提升</a>，不含 Node 8 带来的提升。</li>\n<li>为了方便开发者快速升级，保持了对 Egg 1.x 以及 generator function 的兼容。</li>\n</ul>\n<p><img src=\"//dn-cnode.qbox.me/Fuf5DkXMxM7wfClcN6B6LzX5d18Q\" alt=\"image.png\"></p>\n<h2>如何升级</h2>\n<p><strong><a href=\"https://eggjs.org/\">Egg</a> 的理念之一是渐进式增强，故我们为开发者提供渐进升级的体验。</strong></p>\n<ol>\n<li>Node.js 使用最新的 LTS 版本（&gt;=8.9.0）。</li>\n<li>修改 package.json 中 egg 的依赖为 ^2.0.0。</li>\n<li>检查相关插件是否发布新版本（可选）。</li>\n<li>重新安装依赖，跑单元测试。</li>\n</ol>\n<p><strong>搞定！几乎不需要修改任何一行代码，就已经完成了升级。</strong></p>\n<p>这得益于 Egg 对 1.x 的兼容，但为了更好的统一代码风格，以及更佳的性能和错误堆栈，我们建议开发者参考 <a href=\"https://eggjs.org/zh-cn/migration.html\">升级指南</a> 进一步升级。</p>\n<h2>未来规划</h2>\n<p>如您所知，Egg 采用的是 <strong>『微内核 + 插件 + 上层框架』</strong> 模式。</p>\n<p>其中微内核经过 3 年 4 个版本，以及在阿里的大规模应用，已经打磨的非常稳定。</p>\n<p>接下来我们的<strong>重心主要在开发者体验方面的优化</strong>，包括：</p>\n<ul>\n<li>更好的开发者体验，包括 TypeScript，开发者工具，IDE 工具等方面。</li>\n<li>社区扶持\n<ul>\n<li>协助业界的前端团队，打造适合特定团队业务场景的上层框架，欢迎勾搭。</li>\n<li>分享我们在团队、协作、规范化等方面的经验。</li>\n<li>分享在 Docker，GraphQL，SSR 等方面的探索和最佳实践分享。</li>\n</ul>\n</li>\n<li>国际化，官网和<a href=\"https://github.com/eggjs/egg/issues/363\">文档翻译</a>等。</li>\n</ul>\n<p>同时，我们也欢迎社区更多的<a href=\"https://github.com/orgs/eggjs/projects\">参与</a>，一起打造更完善的生态。</p>\n<p><img src=\"//dn-cnode.qbox.me/Fg_WHGNC13j2azgEWb-ONk5whle5\" alt=\"image.png\"></p>\n<h2>我们这一年</h2>\n<p>截止至今天(2017-12-03)：</p>\n<ul>\n<li><strong>GitHub 5.6k star</strong>，555 forks，npm 月下载量 11,140 (不含阿里内网数据)。</li>\n<li>从 1.0 到 2.0，我们一共发布了 <a href=\"https://github.com/eggjs/egg/releases\">18 个版本</a>，处理了 820 个 issue，收到了 500+ (主库 272) 个 Pull Request 。</li>\n<li>开发者体验方面的优化包括：<a href=\"https://eggjs.org/zh-cn/core/development.html#%E4%BD%BF%E7%94%A8-egg-bin-%E8%B0%83%E8%AF%95\">断点调试代理</a>，<a href=\"https://eggjs.org/zh-cn/core/development.html#%E5%8D%95%E5%85%83%E6%B5%8B%E8%AF%95\">单元测试+覆盖率</a>，<a href=\"https://eggjs.org/zh-cn/core/deployment.html#%E9%83%A8%E7%BD%B2\">部署工具</a>，TypeScript 支持，<a href=\"https://github.com/eggjs/vscode-eggjs\">VSCode 插件</a>，文档优化等等。</li>\n</ul>\n<p><strong>社区方面：</strong></p>\n<ul>\n<li>来自 BAT，丁香园，全民直播等多家兄弟公司的反馈和插件回馈。</li>\n<li>来自 <a href=\"https://github.com/eggjs/egg/network/dependents\">GitHub Dependents</a> 的统计：992 Repositories, 231 Packages</li>\n<li><a href=\"https://npms.io/search?q=egg-\">NPM 搜索结果</a>超过 400 个。</li>\n<li>上层框架：\n<ul>\n<li><a href=\"https://github.com/alibaba/beidou\">北斗</a> - Isomorphic framework for server-rendered React apps</li>\n<li><a href=\"https://github.com/avetjs/avet\">avet</a> - A very comfortable framework for writing isomorphic applications</li>\n</ul>\n</li>\n<li>如果你有好的分享，PR 传送门：<a href=\"https://github.com/eggjs/awesome-egg\">awesome-egg</a></li>\n</ul>\n<p><strong>趣味数据：</strong></p>\n<ul>\n<li>官网访问量中，Mac 占 47% → 这比例挺高的，看来 Node 程序猿都很幸福。</li>\n<li>周末的访问量约为平时的 1/3 → 看来 Node 程序猿周末加班少。（滑稽</li>\n<li>官网访问来源：站内，直链，外链各 30% 多，来自搜索引擎的较少。</li>\n</ul>\n<p><strong>分享交流：</strong></p>\n<ul>\n<li>在 <a href=\"http://2017.jsdc.tw/\">台灣 JSDC2017 開發者年會</a> 和 <a href=\"http://2017.imweb.io/index.html#schedule\">腾讯IMWebConf</a> 分享了『<a href=\"https://github.com/atian25/blog/raw/master/assets/files/Egg%20%26%20Node.js%20%E4%BB%8E%E5%B0%8F%E5%B7%A5%E5%9D%8A%E8%B5%B0%E5%90%91%E4%BC%81%E4%B8%9A%E7%BA%A7%E5%BC%80%E5%8F%91.pdf\">Egg &amp; Node.js 从小工坊走向企业级开发</a>』</li>\n</ul>\n<p><img src=\"//dn-cnode.qbox.me/FgFUrGpNw07LKQPYzGgZp64j7CZH\" alt=\"image.png\"></p>\n<ul>\n<li>Node TSC @张秋怡 在 <a href=\"https://nina17.sched.com/event/Atii/nodejs-at-alibaba-a-joyee-cheung-alibaba-cloud\">Node Interactive North America 2017</a> 和 <a href=\"http://nodefest.jp/2017/schedule.html#joyee\">東京Node学園祭2017</a> 分享了『<a href=\"https://github.com/joyeecheung/talks/blob/master/node_fest_2017/nodejs_at_alibaba_tokyo.pdf\">Node.js at Alibaba</a>』。</li>\n</ul>\n<p><img src=\"//dn-cnode.qbox.me/Fl5IyrfAMzQ49Uz3eQ67i2FLL09H\" alt=\"image.png\"></p>\n<ul>\n<li><a href=\"/user/ngot\">@ngot</a> 在 <a href=\"https://www.bagevent.com/event/751307\">Node Party</a> 分享了『<a href=\"https://github.com/Hangzhou-Node-Party/Node-Party/blob/master/2017-08-19/Egg.js%E5%9C%A8%E9%98%BF%E9%87%8C%E5%B7%B4%E5%B7%B4%E9%9B%86%E5%9B%A2%E7%9A%84%E7%9A%84%E5%AE%9E%E8%B7%B5%E8%BF%90%E7%94%A8.pdf\">Egg.js 在阿里巴巴集团的实践运用</a>』</li>\n<li>@姜天意 在 <a href=\"http://2017.imweb.io/index.html#schedule\">腾讯IMWebConf</a> 分享了 『<a href=\"https://github.com/jtyjty99999/share/blob/master/security%20risk%20in%20node%20web.pdf\">脆弱的 Node.js</a>』</li>\n</ul>\n<h2>写在最后</h2>\n<p>开源，痛并快乐着。</p>\n<p><img src=\"//dn-cnode.qbox.me/Fiamh5LNYR3e2E0HtdhrO3sVfHrs\" alt=\"image.png\"></p>\n</div>",
      "title": "企业级 Node.js 框架 Egg 发布 2.0，性能提升 30%，拥抱 Async",
      "last_reply_at": "2018-03-05T09:11:03.676Z",
      "good": true,
      "top": true,
      "reply_count": 140,
      "visit_count": 26847,
      "create_at": "2017-12-03T13:58:58.901Z",
      "author": {
        "loginname": "atian25",
        "avatar_url": "https://avatars1.githubusercontent.com/u/227713?v=3&s=120"
      }
    },
    {
      "id": "592917b59e32cc84569a7458",
      "author_id": "54009f5ccd66f2eb37190485",
      "tab": "share",
      "content": "<div class=\"markdown-text\"><p>本来提供开发api，目的是为了开发第三方应用或客户端，如果大家用来学习也是好的，但现在很多人太过分了，随意发帖，at，严重影响了社区的用户，故而决定开始严查</p>\n<p>以下情况，直接封号</p>\n<ul>\n<li>测试标题</li>\n<li>无任何内容</li>\n<li>无意义回复</li>\n<li>测试帖，5分钟内没有删除</li>\n</ul>\n<p>欢迎大家监督</p>\n<p>封号</p>\n<ul>\n<li><a href=\"https://cnodejs.org/user/Mwangzhi\">https://cnodejs.org/user/Mwangzhi</a></li>\n<li><a href=\"https://cnodejs.org/user/lw6395\">https://cnodejs.org/user/lw6395</a></li>\n<li><a href=\"https://cnodejs.org/user/shengliang74\">https://cnodejs.org/user/shengliang74</a>  竟然挑衅，发帖说你来打我呀。。。。</li>\n<li><a href=\"https://cnodejs.org/user/h5-17\">https://cnodejs.org/user/h5-17</a> <a href=\"/user/h5-17\">@h5-17</a></li>\n<li><a href=\"https://cnodejs.org/user/592php\">https://cnodejs.org/user/592php</a> <a href=\"/user/592php\">@592php</a></li>\n</ul>\n<hr>\n<p>20170601更新</p>\n<p><a href=\"https://cnodejs.org/?tab=dev\">https://cnodejs.org/?tab=dev</a>  目前开了一个『客户端测试』专区，以后开发新客户端的同学，帖子直接发到这个专区去。tab 的值是 dev。</p>\n<p><img src=\"//dn-cnode.qbox.me/FundjyBuYk60yqQ-PdKstrPKY-7-\" alt=\"image.png\"></p>\n</div>",
      "title": "测试请发到客户端测试专区，违规影响用户的，直接封号",
      "last_reply_at": "2018-02-11T03:14:52.079Z",
      "good": false,
      "top": true,
      "reply_count": 153,
      "visit_count": 41484,
      "create_at": "2017-05-27T06:07:49.278Z",
      "author": {
        "loginname": "i5ting",
        "avatar_url": "https://avatars3.githubusercontent.com/u/3118295?v=4&s=120"
      }
    },
    {
      "id": "53fea1782243147e787fd8a6",
      "author_id": "504c28a2e2b845157708cb61",
      "tab": "ask",
      "content": "<div class=\"markdown-text\"><p>昨天 <a href=\"/user/snoopy\">@snoopy</a> 在 <a href=\"http://cnodejs.org/topic/53fd4de82243147e78396ccf#53fde5b72243147e785a41dc\">能增加个帖子和评论点赞的功能么</a> 这个帖子里说，希望 cnode 可以加上点赞功能。其实我也一直想加上的，但是最近工作还是比较忙。</p>\n<p>想问问大家，还有什么别的意见？</p>\n<p>我先说几点我的想法</p>\n<ol>\n<li>tag 功能不加，检索功能交给搜索引擎</li>\n<li>默认搜索引擎只用 google，不会改为百度。想为这个地方添加配置的朋友欢迎来 pr。</li>\n<li>点赞功能会加上，点赞比较多的帖子和评论，都会用明显的颜色标识出来。但是点赞的算法如何设计？点赞人数超过 5 人就算，还是用点赞数跟浏览数做一定比较来得出？</li>\n<li>用户头像通过七牛进行反向代理。</li>\n<li>适当组织社区活动？奖品什么的，我可以跟 qiniu 与 ucloud 谈一谈，相信它们应该会赞助。但活动的形式应该怎么开展我想得不清楚。</li>\n<li>补全 nodeclub 的测试，精简代码。原来的代码有不少冗余，以及糟糕的表达。这些都只是需要时间就能完成的。</li>\n</ol>\n<p>大家的意思呢？无论技术方面的改进或者是运营方面的改进都欢迎讨论讨论。</p>\n<h3>2014 09 01 更新</h3>\n<p>至今决定优化的地方是：</p>\n<ol>\n<li>为帖子和回复增加点赞功能。用来判断被点赞后，是否属于精品帖的算法待定。</li>\n<li>补全测试代码，使行覆盖率与分支覆盖率达到 80%。</li>\n<li>简化及优化代码。以前的代码中，有很多拙劣的实现，比如：多个查询一起进行时，使用 <code>var count = 0</code> 的变量配合 <code>count++</code>来判断是否完成。</li>\n<li>为友情链接加上图片logo</li>\n<li>用户头像通过七牛代理。但是缓存和过期的细节暂无方案。</li>\n<li>积分等级。根据用户的积分，在用户资料旁显示勋章。</li>\n<li>论坛分为 <code>问答</code>  <code>分享</code>  和 <code>求职</code> 三个板块，并有一个 <code>全部</code> 版块。共四个。</li>\n<li>npm 模块升级，比如 <code>validator</code> 模块现在很旧了。</li>\n<li>xss 模块重新设计。我个人觉得目前的 xss 模块效率太低。</li>\n<li>去掉 User model 中的 name 属性，只保留 loginname。</li>\n</ol>\n<h3>2014 09 04 更新</h3>\n<ol>\n<li><a href=\"https://github.com/cnodejs/nodeclub/issues/387\">https://github.com/cnodejs/nodeclub/issues/387</a></li>\n<li><a href=\"https://github.com/cnodejs/nodeclub/pull/388\">https://github.com/cnodejs/nodeclub/pull/388</a></li>\n</ol>\n<h3>2014 09 05 更新</h3>\n<ol>\n<li>加上七牛的赞助标识</li>\n<li>mongoose 升级到 3.x <a href=\"https://github.com/cnodejs/nodeclub/issues/389\">https://github.com/cnodejs/nodeclub/issues/389</a></li>\n</ol>\n</div>",
      "title": "询问大家对 cnode 的意见和建议",
      "last_reply_at": "2018-03-05T15:02:35.262Z",
      "good": false,
      "top": false,
      "reply_count": 79,
      "visit_count": 3728,
      "create_at": "2014-08-28T03:26:48.882Z",
      "author": {
        "loginname": "alsotang",
        "avatar_url": "https://avatars1.githubusercontent.com/u/1147375?v=4&s=120"
      }
    },
    {
      "id": "5a98f166ce1c90bc44c445b9",
      "author_id": "5909444b782dbc4b183ecfe2",
      "tab": "share",
      "content": "<div class=\"markdown-text\"><p>基于在上一家公司的开发经验，沉淀而来的web框架。</p>\n<p>Kost 基于 Koa，使用 Typescript 编写，借鉴于 egg 的<strong>约定大于配置</strong>的思想以及 nest 的依赖注入和装饰器路由。</p>\n<p>是一款内置多个功能，并遵循一系列规范的 Web 框架。</p>\n<h3>框架架构</h3>\n<p><img src=\"https://raw.githubusercontent.com/axetroy/kost/master/kost.png\" alt=\"kost\"></p>\n<h2>Q &amp; A</h2>\n<p>Q: 为什么开发这样的框架</p>\n<blockquote>\n<p>A: 框架基于以前的项目经验沉淀而来，首先是坚持 Typescript 不动摇，能在开发阶段避免了很多 bug。</p>\n</blockquote>\n<p>Q: 为什么不使用 nest？</p>\n<blockquote>\n<p>A: 因为它是基于 Express，而我以前的项目都是 Typescript + Koa</p>\n</blockquote>\n<p>Q: 为什么不使用 egg?</p>\n<blockquote>\n<p>A: egg 使用 JS 开发，目前对 Typescript 没有一个很好的方案(见识短，没发现)，而且 egg 的 service 会丢失类型 IDE 提示，目前 egg 成员已在着手解决这个问题，期待中…</p>\n</blockquote>\n<p>Q: 与两者的框架区别在哪里?</p>\n<blockquote>\n<p>A: 借鉴了 egg 的约定大于配置的思想，约定了一些文件目录，文件名，如果不按照框架写，就会 boom。借鉴了 nest 的 OOP 编程思想，所有的，包括 Controller、Service、Middleware 都是类，都可以进行依赖注入，而且路由定义是装饰器风格，语法糖会让你更加的直观。对于开发而言，会有很好的 IDE 提示。</p>\n</blockquote>\n<p>Q: 框架内置了一些特性，会不会平白增加性能负担？</p>\n<blockquote>\n<p>A: 根据你是否开启特性，来决定是否引入包，所以不会有性能损耗。</p>\n</blockquote>\n<p>Q: 是否需要配套 CLI 工具?</p>\n<blockquote>\n<p>A: 目前没有，编译成 JS 就能运行，可以用 pm2 进行负载均衡。</p>\n</blockquote>\n<p>Q: 框架是否包含进程管理?</p>\n<blockquote>\n<p>A: 框架本身不进行进程管理，没有类似 egg 的 master 主进程管理子进程，没有 agent</p>\n</blockquote>\n<h2>何为开源</h2>\n<p>开源就是自己用的爽的东西，拿出来给大家用，然后发现你自己写的，用法和原理你肯定懂啊，但是别人不懂，你得写文档，维护文档的时间，不必写代码的时间少。</p>\n<p>同时为了保证项目质量，你还得写测试用例，写测试用例的时间，也并不少。</p>\n<p>要维护一个开源项目，真的是要花不少心思，向开源大牛致敬。</p>\n<h2>总结</h2>\n<p>实现起来没什么难度，前人栽树，后人乘凉，继承自Koa的类，然后在start之前，做一些初始化动作，加载Controller，验证Controller、Middleware、Service是否正确，加载配置文件等工作…</p>\n<p>从创建仓库到现在100+个commit，而大多数commit都是更新文档，添加测试用例，最近也忙，断断续续的维护，今天终于完善了测试用例，覆盖率99%，终于可以发布第一个版本。</p>\n<p>有兴趣的小伙伴，一起来维护吗，交个朋友</p>\n<p>最后上项目地址: <a href=\"https://github.com/axetroy/kost\">https://github.com/axetroy/kost</a></p>\n</div>",
      "title": "一个装饰器风格，依赖注入，OOP的Web框架",
      "last_reply_at": "2018-03-05T14:28:33.455Z",
      "good": false,
      "top": false,
      "reply_count": 12,
      "visit_count": 453,
      "create_at": "2018-03-02T06:38:30.463Z",
      "author": {
        "loginname": "axetroy",
        "avatar_url": "https://avatars2.githubusercontent.com/u/9758711?v=4&s=120"
      }
    },
    {
      "id": "5a9d27132ffb8598445aeb75",
      "author_id": "5880c72c1dc8ff8739cbc4d8",
      "tab": "ask",
      "content": "<div class=\"markdown-text\"><p><img src=\"//dn-cnode.qbox.me/FjgTr0u8XBc-pSD8L3lVDu7n9MNE\" alt=\"微信图片_20180304154800.png\">\n固定了发送的字符串，是WIFI串口\n我看过有人用serialport那个包，但是安装不成功 [哭]\n<img src=\"//dn-cnode.qbox.me/FhGGjiPLuMr7z5OzF9p5Fu8h-QWY\" alt=\"QQ图片20180305185755.png\">\n我win10系统，net.framework 2.0 sdk系统自带\n<img src=\"//dn-cnode.qbox.me/FpOur8Z5XiJflLOKw_SqCbfHXucE\" alt=\"QQ图片20180305190953.png\">\n然后visual studio 是2017…</p>\n</div>",
      "title": "最近在想一个web串口项目，有大神给个项目参考吗？",
      "last_reply_at": "2018-03-05T13:43:38.705Z",
      "good": false,
      "top": false,
      "reply_count": 3,
      "visit_count": 83,
      "create_at": "2018-03-05T11:16:35.682Z",
      "author": {
        "loginname": "Luokejin",
        "avatar_url": "https://avatars2.githubusercontent.com/u/19741491?v=4&s=120"
      }
    },
    {
      "id": "59e86107a9a1e19f3634c871",
      "author_id": "58f8dcba31e8c2bb1c3dcc26",
      "tab": "ask",
      "content": "<div class=\"markdown-text\"><p>如题，公司选型中有多少选择egg.js的？（个人项目除外）。</p>\n<p>个人感觉，egg的插件还不是特别完善，看到egg issue问题中好多人提的问题，作者都想大家去PR，这出发点是好的，但是在公司中，遇到问题就需要自己去PR的话，很花时间啊。如果是个人项目还是可以贡献代码的，因为时间允许。如何做出选择，我的备选方案是koa2和egg。我更倾向于koa2。</p>\n</div>",
      "title": "公司选型中有多少选择egg.js的？（个人项目除外）",
      "last_reply_at": "2018-03-05T12:32:08.751Z",
      "good": false,
      "top": false,
      "reply_count": 42,
      "visit_count": 4059,
      "create_at": "2017-10-19T08:23:35.792Z",
      "author": {
        "loginname": "MedusaLeee",
        "avatar_url": "https://avatars0.githubusercontent.com/u/17797874?v=4&s=120"
      }
    },
    {
      "id": "5a9d22d32ffb8598445aeb74",
      "author_id": "53d50dbd895ba3062bc5f07f",
      "tab": "share",
      "content": "<div class=\"markdown-text\"><p>git地址：<a href=\"https://github.com/wangbinlml/express-admin\">https://github.com/wangbinlml/express-admin</a></p>\n<p>Demo地址\n<a href=\"http://a.chenxun.org\">http://a.chenxun.org</a>\nusername: test\npassword: test</p>\n<p><strong><em>麻烦大家不要删数据哈</em></strong></p>\n<p>1.登录\n<img src=\"//dn-cnode.qbox.me/Finfgz8PWQobw4wrDIg7PWLvVVWS\" alt=\"login.png\">\n2.内容页\n<img src=\"//dn-cnode.qbox.me/FhQPONYZumypI6rWLZ6Xo9EwxInZ\" alt=\"main.png\"></p>\n<p>欢迎拍砖。</p>\n</div>",
      "title": "分享基于NodeJS Express Bootstrap 后台管理系统，包括用户，登录，角色，菜单权限等。",
      "last_reply_at": "2018-03-05T11:57:10.996Z",
      "good": false,
      "top": false,
      "reply_count": 1,
      "visit_count": 91,
      "create_at": "2018-03-05T10:58:27.327Z",
      "author": {
        "loginname": "wangbinlml",
        "avatar_url": "https://avatars0.githubusercontent.com/u/1274859?v=4&s=120"
      }
    },
    {
      "id": "5a7ccb3c8d6e16e56bb8069f",
      "author_id": "545b74143e1f39344c5b3bee",
      "tab": "ask",
      "content": "<div class=\"markdown-text\"><pre class=\"prettyprint\"><code>var asdfsdf = {\n\tsdfsdf: [\n\t\t[&#x27;aaaaa&#x27;, &#x27;aaaaa&#x27;],\n\t\t[&#x27;adsfsadf&#x27;, &#x27;wfwfwef&#x27;],\n\t\t[&#x27;--sdf-&#x27;,&#x27;asdfasdf&quot;&gt;asdfsadfsdf&gt;&#x27;],\n\t\t[&#x27;afds&#x27;],\n\t\t[&#x27;asdf&#x27;],\n\t\t[&#x27;sfdaf&#x27;],\n\t\t[&#x27;adf&#x27;,[&#x27;adsf&#x27;,&#x27;sdf&#x27;,&#x27;asdf&#x27;], &#x27;sdf:sdf&#x27;]\n\t\t[&#x27;-df--&#x27;],\n\t\t[&#x27;sfd&#x27;, &#x27;dsf:sdf&#x27;],\n\t]\n};\n</code></pre><p>[‘adf’,[‘adsf’,‘sdf’,‘asdf’], ‘sdf:sdf’] 这句后门的逗号没写，但是jshint语法检测为何没有报错？</p>\n<p>jshint检测通过\n[JSHint: D:\\workspace\\test.js]\n✓ 0 errors, [esc] to hide.\n[Finished in 0.3s]</p>\n</div>",
      "title": "下面这段JS代码，什么语法检测工具可以发现错在哪里？",
      "last_reply_at": "2018-03-05T11:06:16.463Z",
      "good": false,
      "top": false,
      "reply_count": 11,
      "visit_count": 821,
      "create_at": "2018-02-08T22:12:12.476Z",
      "author": {
        "loginname": "chapgaga",
        "avatar_url": "https://avatars0.githubusercontent.com/u/9590859?v=4&s=120"
      }
    },
    {
      "id": "5a9ac46d8edf56a34493701f",
      "author_id": "58059a0d487e1e4578afb5ca",
      "tab": "ask",
      "content": "<div class=\"markdown-text\"><pre class=\"prettyprint language-js\"><code>const original = Promise.resolve(2)\nnew Promise((resolve) =&gt; {\n\tresolve(original);\n\tPromise.resolve().then(() =&gt; Promise.resolve().then(() =&gt; console.log(1)))\n\tconsole.log(4)\n}).then(t =&gt; console.log(t))\nconsole.log(3)\n</code></pre><p>这样一段代码.\n按照我的理解\n因为original已经被resolve，所以它的状态被new Promise继承\n然后执行Promise.resolve并注册回调\n然后打印4\n然后注册new Promise的回调\n然后打印3\n然后执行第一个注册的回调，并注册第三个回调\n然后打印t，也就是2\n然后执行第三个回调，也就是1</p>\n<p>可是执行结果却是4，3，1，2\n想不通为什么，特来求教！\n谢谢各位大牛~~~</p>\n</div>",
      "title": "请教一个promise执行顺序的问题，有关resolve一个promise以及注册callback的顺序",
      "last_reply_at": "2018-03-05T09:31:26.542Z",
      "good": false,
      "top": false,
      "reply_count": 13,
      "visit_count": 384,
      "create_at": "2018-03-03T15:51:09.890Z",
      "author": {
        "loginname": "StudentWan",
        "avatar_url": "https://avatars2.githubusercontent.com/u/19220708?v=4&s=120"
      }
    },
    {
      "id": "5a9ca3b889a57ad544fa4228",
      "author_id": "5a31e1a6f15b4f306d2f0320",
      "tab": "ask",
      "content": "<div class=\"markdown-text\"><p>如果A用户和B用户同时请求了服务器，服务器处理每个请求需要10s才能返回给用户，\n①：如果nodejs是单线程的，使用异步，将10s的查询结果插入到event loop里，怎么原路返回给用户？res.end()也是使用libuv利用事件函数操作了系统线程返回到对应的用户的机器的吗？\n②：js没有io操作能力，利用了libuv进行io操作？，都是js单线程，性能高因为不用应对每个用户请求创建新线程，线程创建和销毁造成资源浪费？但是nodejs底层的libuv是多线程的线程池用来并行io操作？如果是的话，那么libuv多线程创建，销毁不会对资源造成浪费吗？如果页造成浪费，那么在js胶水语言层的单线程又能减少多少系统资源呢？</p>\n<p>以上都是小弟迷惑的地方，请了解详情的大佬指点一二。感谢ing</p>\n</div>",
      "title": "请问大佬们，都说nodejs是单线程的？",
      "last_reply_at": "2018-03-05T09:31:17.668Z",
      "good": false,
      "top": false,
      "reply_count": 6,
      "visit_count": 384,
      "create_at": "2018-03-05T01:56:08.529Z",
      "author": {
        "loginname": "1316346949",
        "avatar_url": "https://avatars1.githubusercontent.com/u/24400797?v=4&s=120"
      }
    },
    {
      "id": "5a9cf82f77dc4e0d2136ae0b",
      "author_id": "595d976b10d696af07768a24",
      "tab": "share",
      "content": "<div class=\"markdown-text\"><h1>express搭建的淘宝客网站</h1>\n<blockquote>\n<p>测试地址: <a href=\"http://www.5aiss.com\">www.5aiss.com</a></p>\n</blockquote>\n<blockquote>\n<p>项目地址：<a href=\"https://gitee.com/null_639_7345/taobaoke\">https://gitee.com/null_639_7345/taobaoke</a></p>\n</blockquote>\n<h2>效果</h2>\n<p><img src=\"//dn-cnode.qbox.me/FhODBX0aEYv9S_vHNMupGOJMyLiK\" alt=\"1.png\">\n<img src=\"//dn-cnode.qbox.me/FnOFioCtmxAAwd-Hp6NavqrRpaV2\" alt=\"2.png\">\n<img src=\"//dn-cnode.qbox.me/FpsOnYTFTJo1tdbBuahPTb1MUjFm\" alt=\"3.png\">\n<img src=\"//dn-cnode.qbox.me/FgvpMq9M5kIyt7Qg0gAlvSxIXcnt\" alt=\"4.png\"></p>\n<h2>1.运行</h2>\n<ul>\n<li>安装mongodb数据库</li>\n<li>修改配置文件config/default.js</li>\n<li>配置淘宝api信息\n\\taobaoke\\server\\tbk\\TbkAPI.js</li>\n</ul>\n<pre class=\"prettyprint language-js\"><code>var client = new TopClient({\n  appkey: &quot;***&quot;,&#x2F;&#x2F;你的appkey\n  appsecret: &quot;***&quot;,&#x2F;&#x2F;appsecret\n  REST_URL: &quot;http:&#x2F;&#x2F;gw.api.taobao.com&#x2F;router&#x2F;rest&quot;\n});\n\nlet api = (module.exports = {\n  adzone_id: &quot;***&quot;,&#x2F;&#x2F;你的adzone_id\n  fields:&#x27;num_iid,title,pict_url,small_images,reserve_price,zk_final_price,user_type,provcity,item_url&#x27;\n});\n\n</code></pre><blockquote>\n<p>不清楚的请参考-book/淘宝客API使用方法.doc</p>\n</blockquote>\n<ul>\n<li>安装依赖库</li>\n</ul>\n<pre class=\"prettyprint language-sh\"><code>npm i gulp -g\nnpm i\n</code></pre><ul>\n<li>前端打包</li>\n</ul>\n<pre class=\"prettyprint language-sh\"><code>gulp\n</code></pre><ul>\n<li>启动web服务</li>\n</ul>\n<pre class=\"prettyprint language-sh\"><code>node .&#x2F;bin&#x2F;www\n</code></pre></div>",
      "title": "express搭建的淘宝客网站",
      "last_reply_at": "2018-03-05T09:29:36.333Z",
      "good": false,
      "top": false,
      "reply_count": 1,
      "visit_count": 158,
      "create_at": "2018-03-05T07:56:31.091Z",
      "author": {
        "loginname": "18820227745",
        "avatar_url": "https://avatars0.githubusercontent.com/u/25097125?v=4&s=120"
      }
    },
    {
      "id": "5a9ce1ba8edf56a344937075",
      "author_id": "59005c8131e8c2bb1c3dce78",
      "tab": "ask",
      "content": "<div class=\"markdown-text\"><p>如题，nodejs如何去监听mysql数据库的指定的某一张表里面有新的数据插入？</p>\n</div>",
      "title": "nodejs如何去监听数据库里面有新的数据插入？",
      "last_reply_at": "2018-03-05T09:21:37.592Z",
      "good": false,
      "top": false,
      "reply_count": 4,
      "visit_count": 202,
      "create_at": "2018-03-05T06:20:42.161Z",
      "author": {
        "loginname": "hcyhehe",
        "avatar_url": "https://avatars1.githubusercontent.com/u/15827573?v=4&s=120"
      }
    },
    {
      "id": "5a9ceb1a77dc4e0d2136ae06",
      "author_id": "595d976b10d696af07768a24",
      "tab": "share",
      "content": "<div class=\"markdown-text\"><p>不要问我为啥要写这样的代码，嘿嘿嘿~~~~~</p>\n<h2>1.文章自动上传到<a href=\"https://steemit.com/login.html\">steemit</a>上</h2>\n<p>本来想分析网站的api进行上传的，没想到steemit做了众多限制，感觉有些麻烦所以采用直接控制浏览器的方法上传文章。\nnode.js使用<a href=\"https://www.npmjs.com/package/selenium-webdriver\">selenium-webdriver</a>模块可以轻松控制浏览器。</p>\n<pre class=\"prettyprint language-js\"><code>\n  &#x2F;**\n   * 登录\n   *&#x2F;\n  async login() {\n    let url = &#96;https:&#x2F;&#x2F;steemit.com&#x2F;login.html&#96;;\n    let _this = this;\n    let returnJson = {\n      result: false,\n      value: &quot;&quot;\n    };\n    return new Promise(async (resolve, reject) =&gt; {\n      await _this.web.get(url);\n      await _this.web.findElements(By.css(&quot;input&quot;)).then(async res =&gt; {\n        await res[1].sendKeys(_this.__username);&#x2F;&#x2F;设置登录用户名\n        await res[2].sendKeys(_this.__password);&#x2F;&#x2F;设置登录密码\n        await _this.web\n          .findElement(By.css(&quot;.login-modal-buttons&gt;button&quot;))\n          .click();\n        await _this.web.wait(until.urlIs(&quot;https:&#x2F;&#x2F;steemit.com&#x2F;welcome&quot;), 4000);\n        await _this.web\n          .findElement(By.css(&quot;.show-for-medium.submit-story&quot;))\n          .click();\n        returnJson.result = true;\n        returnJson.value = &quot;login success&quot;;\n        console.log(&quot;login success&quot;);\n        resolve(returnJson);\n        return returnJson;\n      });\n    });\n  }\n\n  &#x2F;**\n   * 提交文章\n   * @param {*} title 文章标题\n   * @param {*} post 文章体\n   * @param {*} tags 文章标签\n   *&#x2F;\n  async submit(title, post, tags) {\n    let url = &#96;https:&#x2F;&#x2F;steemit.com&#x2F;submit.html&#96;;\n    let _this = this;\n    let returnJson = {\n      result: false,\n      value: &quot;&quot;\n    };\n    return new Promise(async (resolve, reject) =&gt; {\n      await _this.web.get(url);\n      &#x2F;&#x2F;设定延时,确保进入提交页面\n      await _this.web.wait(\n        until.urlIs(&quot;https:&#x2F;&#x2F;steemit.com&#x2F;submit.html&quot;),\n        4000\n      );\n      &#x2F;&#x2F;标签定位，打开网页分析一下就oK了\n      await _this.web.findElements(By.css(&quot;input&quot;)).then(async res =&gt; {\n        await res[1].sendKeys(title);\n        await res[3].sendKeys(tags);\n        await _this.web.wait(until.elementLocated(By.css(&quot;textarea&quot;)), 3000);\n        await _this.web.findElement(By.css(&quot;textarea&quot;)).sendKeys(post);\n        await _this.web.findElement(By.css(&quot;.button&quot;)).click();\n        returnJson.result = true;\n        returnJson.value = &quot;submit success&quot;;\n        resolve(returnJson);\n        return returnJson;\n      });\n    });\n  }\n</code></pre><p>标签定位大家只用打开浏览器看一下就知道了\n先调用登录接口，登录成功后调用上传文章接口</p>\n<h2>2.文章来源-从<a href=\"https://medium.com\">medium</a>批量下载文章到redis队列</h2>\n<p>根据一位道友提供的api接口可以根据作者名获取到该作者的文章列表。</p>\n<pre class=\"prettyprint language-js\"><code>  &#x2F;**\n   * 获取Medium文章列表\n   * @param {*} user\n   * @param {*} limit\n   *&#x2F;\n  async getPostByUsername(username, limit) {\n    let returnJson = {\n      result: false,\n      value: &quot;&quot;\n    };\n    let _this = this;\n    return new Promise((resolve, reject) =&gt; {\n      if (\n        typeof limit != &quot;number&quot; ||\n        limit &lt;= 0 ||\n        limit &gt; 100 ||\n        typeof username != &quot;string&quot; ||\n        username === &quot;&quot;\n      ) {\n        returnJson.result = false;\n        returnJson.value = &quot;参数不正确&quot;;\n        resolve(returnJson);\n        return returnJson;\n      } else {\n        let JSONDate = {\n          query: &#96;query PostQuery($username: String!, $limit: Int!){\n                posts(username: $username, limit: $limit) {\n                  title\n                  firstPublishedAt\n                  url\n                  content {\n                    subtitle\n                  }\n                }\n                user(username: $username) {\n                  username\n                  name\n                  bio\n                }\n              }&#96;,\n          variables: &#96;{\n                &quot;username&quot;: &quot;${username}&quot;,\n                &quot;limit&quot;: ${limit}\n              }&#96;,\n          operationName: &quot;PostQuery&quot;\n        };\n\n        superagent\n          .post(&quot;https:&#x2F;&#x2F;micro-medium-api.now.sh&#x2F;graphql&quot;)\n          .send(JSONDate) &#x2F;&#x2F; sends a JSON post body\n          .set(&quot;accept&quot;, &quot;json&quot;)\n          .end((err, res) =&gt; {\n            if (err) {\n              console.log(&quot;获取文章列表出错： &quot;, err);\n              returnJson.result = false;\n              returnJson.value = &quot;获取文章列表出错： &quot; + err;\n              resolve(returnJson);\n              return returnJson;\n            } else {\n              returnJson.result = true;\n              returnJson.value = res.text;\n              resolve(returnJson);\n              return returnJson;\n            }\n          });\n      }\n    });\n  }\n</code></pre><p>又是一个神器h2m,(根据url将html转化成md)</p>\n<pre class=\"prettyprint language-js\"><code>npm install h2m -g\nh2m https:&#x2F;&#x2F;baidu.com\n</code></pre><p>于是我有封装了一个接口</p>\n<pre class=\"prettyprint language-js\"><code>  &#x2F;**\n   * 根据url下载Medium文章到本地\n   * @param {*} url\n   * @param {*} savePath\n   * @param {*} saveName\n   *&#x2F;\n  async downloadPostByUrl(url, saveName,author,category) {\n    let returnJson = {\n      result: false,\n      value: &quot;&quot;\n    };\n    let _this = this;\n    url = encodeURI(url);\n    return new Promise((resolve, reject) =&gt; {\n      if (url === &quot;&quot; || saveName === &quot;&quot; ) {\n        returnJson.result = false;\n        returnJson.value = &quot;参数不正确&quot;;\n        resolve(returnJson);\n        return returnJson;\n      } else {\n        let command = &#96;h2m ${url}&#96;;\n        console.log(command);\n        exec(command, {timeout: 1000*60*3,maxBuffer: 20*1024*1024},(error, stdout, stderr) =&gt; {\n          console.log(&#96;stderr: ${stderr}&#96;);\n          if (error) {\n            console.log(&#96;exec error: ${error}&#96;);\n            returnJson.result = false;\n            returnJson.value = &#96;exec error: ${error}&#96;;\n            resolve(returnJson);\n          } else {\n            returnJson.result = true;\n            returnJson.value = &#96;根据url下载Medium文章到本地成功&#96;;\n            console.log(&#x27;根据url下载Medium文章到本地成功&#x27;);\n            resolve(returnJson);\n            let saveStr = stdout.slice(stdout.indexOf(&#x27;\\n\\n---\\n&#x27;),stdout.indexOf(&#x27;One clap, two clap, three clap, forty?&#x27;))\n            let title = saveName;\n            let postJson = {\n              title: title,\n              author: author,\n              category: category,\n              content: saveStr\n            }\n\t\t\t&#x2F;&#x2F;存储到redis队列中\n            _this.queueJson[category].publish(postJson)\n          }\n          return returnJson;\n        });\n      }\n    });\n  }\n</code></pre><blockquote>\n<p>小坑：exec使用时stdout, stderr默认大小是200K,要把maxBuffer设置大一点才行。</p>\n</blockquote>\n<h2>3.如何保证上传的文章不重复呢？</h2>\n<p>真心感谢无所不能的npm\n使用<a href=\"https://www.npmjs.com/package/redis-message-queue\">redis-message-queue</a>可以轻松创建出值唯一的redis队列。</p>\n<pre class=\"prettyprint language-js\"><code>this.client = new rmq.UniqueQueue(this.name, port, host);\n</code></pre><h2>4.运行</h2>\n<p>代码位置：<a href=\"https://gitee.com/null_639_7345/steemit\">https://gitee.com/null_639_7345/steemit</a>\n1.git代码到本地\n2.下载<a href=\"https://www.npmjs.com/package/selenium-webdriver\">firefox驱动文件</a>到本地，安装firefox浏览器\n3.npm i h2m -g\n4.修改配置文件config/default.js</p>\n<pre class=\"prettyprint language-js\"><code>module.exports = {\n    cwd : &#x27;F:\\\\test1\\\\steemit\\\\&#x27;,&#x2F;&#x2F;项目根目录\n    redisHost: &#x27;192.168.10.6&#x27;,&#x2F;&#x2F;redis服务器ip\n    redisPost: 6379,\n    promulgatorName: &#x27;***&#x27;,&#x2F;&#x2F;steemit用户名\n    promulgatorPassword: &quot;***&quot;,&#x2F;&#x2F;steemit密码\n    categories:[\n        {\n            name: &#x27;popular&#x27;,&#x2F;&#x2F;steemit上传文章的分类（tag）\n            &#x2F;&#x2F;Medium的作者列表\n            origin: [&#x27;joshrose&#x27;,&#x27;JessicaLexicus&#x27;,&#x27;ThunderPuff&#x27;,&#x27;usemuzli&#x27;,&#x27;black_metallic&#x27;]\n        }\n    ]\n};\n</code></pre><p>5.node index.js</p>\n<p>最后可以告诉大家一个激动的好消息。\n<img src=\"//dn-cnode.qbox.me/FoFBUiNarQfNHAVdTq3bAkeuuw5E\" alt=\"image.png\"></p>\n</div>",
      "title": "一只搬运文章的小毛贼",
      "last_reply_at": "2018-03-05T09:19:18.441Z",
      "good": false,
      "top": false,
      "reply_count": 4,
      "visit_count": 209,
      "create_at": "2018-03-05T07:00:42.765Z",
      "author": {
        "loginname": "18820227745",
        "avatar_url": "https://avatars0.githubusercontent.com/u/25097125?v=4&s=120"
      }
    },
    {
      "id": "5516736ce26684ed7ff21e0f",
      "author_id": "545b74143e1f39344c5b3bee",
      "tab": "ask",
      "content": "<div class=\"markdown-text\"><p>下面代码运行后会把jquery.js拷贝到dist/jquery.js\n但是我要的效果是保留static/jquery/路径信息,即拷贝后的文件路径是 dist/static/jquery/jquery.js\n如何做到呢?</p>\n<p>在gulp.dest里写全路径太麻烦了,有啥简单点的办法?</p>\n<pre class=\"prettyprint language-js\"><code>gulp.task(&#x27;build&#x27;, function(){\n  gulp.src(&#x27;static&#x2F;jquery&#x2F;jquery.js&#x27;).pipe(gulp.dest(&#x27;dist&#x27;));\n});\n</code></pre></div>",
      "title": "gulp拷贝文件的时候如何保持路径?",
      "last_reply_at": "2018-03-05T09:17:59.733Z",
      "good": false,
      "top": false,
      "reply_count": 3,
      "visit_count": 13869,
      "create_at": "2015-03-28T09:25:00.402Z",
      "author": {
        "loginname": "chapgaga",
        "avatar_url": "https://avatars0.githubusercontent.com/u/9590859?v=4&s=120"
      }
    },
    {
      "id": "5a9ce1d48edf56a344937076",
      "author_id": "59fa85b2e95aa6373e17fd64",
      "tab": "share",
      "content": "<div class=\"markdown-text\"><p><a href=\"https://github.com/five6/five6_forum\">地址</a></p>\n</div>",
      "title": "分享一个使用vue+egg开发一简单的博客 | 论坛。",
      "last_reply_at": "2018-03-05T08:39:13.568Z",
      "good": false,
      "top": false,
      "reply_count": 1,
      "visit_count": 217,
      "create_at": "2018-03-05T06:21:08.599Z",
      "author": {
        "loginname": "five6",
        "avatar_url": "https://avatars1.githubusercontent.com/u/21968901?v=4&s=120"
      }
    },
    {
      "id": "5a9ccdd12ffb8598445aeb4f",
      "author_id": "5a9ccd2f2ffb8598445aeb4e",
      "tab": "ask",
      "content": "<div class=\"markdown-text\"><p><img src=\"//dn-cnode.qbox.me/FkLUmWexJbbTrQfbJltp3p-OWxT0\" alt=\"image.png\"></p>\n</div>",
      "title": "执行接口里的fs.rename，报错：operation not permitted,rename。。。",
      "last_reply_at": "2018-03-05T06:22:05.102Z",
      "good": false,
      "top": false,
      "reply_count": 1,
      "visit_count": 111,
      "create_at": "2018-03-05T04:55:45.193Z",
      "author": {
        "loginname": "xinzai2014",
        "avatar_url": "https://avatars3.githubusercontent.com/u/24290736?v=4&s=120"
      }
    },
    {
      "id": "595d9ad5a4de5625080fe118",
      "author_id": "595d976b10d696af07768a24",
      "tab": "share",
      "content": "<div class=\"markdown-text\"><h1>Mongoose快速入门</h1>\n<h1>1.基础介绍</h1>\n<h2>1.1安装 引用</h2>\n<p>启动数据库命令</p>\n<pre class=\"prettyprint\"><code>\tmongod --dbpath=D:\\Data\\mongodb\\_data\n</code></pre><p>–dbpath：指定数据存储位置</p>\n<p>连接本地的test数据库</p>\n<pre class=\"prettyprint\"><code>\tvar mongoose = require(&#x27;mongoose&#x27;);\n\n\tvar db = mongoose.connect(&quot;mongodb:&#x2F;&#x2F;127.0.0.1:27017&#x2F;test&quot;);\n\n\tdb.connection.on(&quot;error&quot;, function (error) {\n\n    \tconsole.log(&quot;数据库连接失败：&quot; + error);\n\n\t});\n\n\tdb.connection.on(&quot;open&quot;, function () {\n\n   \t\tconsole.log(&quot;------数据库连接成功！------&quot;);\n\n\t});\n</code></pre><h2>1.2 Schema简介</h2>\n<p>Schema：一种以文件形式存储的数据库模型骨架，无法直接通往数据库端，也就是说它不具备对数据库的操作能力，仅仅只是数据库模型在程序片段中的一种表现，可以说是数据属性模型(传统意义的表结构)，又或着是&quot;集合&quot;的模型骨架。</p>\n<p>那如何去定义一个Schema呢，请看示例：</p>\n<pre class=\"prettyprint\"><code>\tvar mongoose = require(&quot;mongoose&quot;);\n\n\tvar TestSchema = new mongoose.Schema({\n\n    \tname : { type:String },&#x2F;&#x2F;属性name,类型为String\n\n    \tage  : { type:Number, default:0 },&#x2F;&#x2F;属性age,类型为Number,默认为0\n\n    \ttime : { type:Date, default:Date.now },\n\n    \temail: { type:String,default:&#x27;&#x27;}\n\n\t});\n</code></pre><blockquote>\n<p>注：Schema定义集合结构（定义表的列）</p>\n</blockquote>\n<h2>1.3 Model–操作数据库</h2>\n<pre class=\"prettyprint\"><code>\n\tvar db = mongoose.connect(&quot;mongodb:&#x2F;&#x2F;127.0.0.1:27017&#x2F;test&quot;);\n\n\t&#x2F;&#x2F; 创建Model\n\n\tvar TestModel = db.model(&quot;test1&quot;, TestSchema);\n\n## 1.4 Entity--给集合赋值\n\n\tvar TestEntity = new TestModel({\n\n      \t name : &quot;Lenka&quot;,\n\n       \tage  : 36,\n\n       \temail: &quot;lenka@qq.com&quot;\n\n\t});\n\n\tconsole.log(TestEntity.name); &#x2F;&#x2F; Lenka\n\n\tconsole.log(TestEntity.age); &#x2F;&#x2F; 36\n</code></pre><h2>1.5 创建集合</h2>\n<pre class=\"prettyprint\"><code>\t&#x2F;&#x2F;引入数据库模块\n\n\tvar mongoose = require(&quot;mongoose&quot;);\n\n\t&#x2F;&#x2F;连接本地名为test的数据库，格式\n\n\t&#x2F;&#x2F;var db = mongoose.connect(&quot;mongodb:&#x2F;&#x2F;user:pass@localhost:port&#x2F;database&quot;);\n\n\tvar db = mongoose.connect(&quot;mongodb:&#x2F;&#x2F;127.0.0.1:27017&#x2F;test&quot;);\n\n\t&#x2F;&#x2F;用Schema定义集合结构\n\n\tvar TestSchema = new mongoose.Schema({\n\n    \tname : { type:String },\n\n    \tage  : { type:Number, default:0 },\n\n    \temail: { type:String },\n\n    \ttime : { type:Date, default:Date.now }\n\n\t});\n\n\t&#x2F;&#x2F;创建model,在内存中创建结构为TestSchema名为test1的集合\n\n\tvar TestModel = db.model(&quot;test1&quot;, TestSchema );\n\n\t&#x2F;&#x2F;插入数据到内存中的test1集合\n\n\tvar TestEntity = new TestModel({\n\n    \tname : &quot;helloworld&quot;,\n\n    \tage  : 28,\n\n    \temail: &quot;helloworld@qq.com&quot;\t\n\n\t});\n\n\t&#x2F;&#x2F;将test1写入到数据库中\n\n\tTestEntity.save(function(error,doc){\n\n  \tif(error){\n\n     \tconsole.log(&quot;error :&quot; + error);\n\n  \t}else{\n\n     \tconsole.log(doc);\n\n  \t}\n\n\t});\n</code></pre><h2>1.6 小结</h2>\n<p>本章节学习了如何通过Mongoose去创建一个数据库&quot;集合&quot;，还有定义&quot;集合&quot;的基本组成结构并使其具有相应的操作数据库能力。</p>\n<p>简单回顾：</p>\n<ol>\n<li>\n<p>Schema：数据库集合的模型骨架，或者是数据属性模型传统意义的表结构。</p>\n</li>\n<li>\n<p>Model ：通过Schema构造而成，除了具有Schema定义的数据库骨架以外，还可以具体的操作数据库。</p>\n</li>\n<li>\n<p>Entity：通过Model创建的实体，它也可以操作数据库。</p>\n</li>\n</ol>\n<h1>2 增删改查</h1>\n<h2>2.1查询</h2>\n<pre class=\"prettyprint\"><code>find查询： obj.find(查询条件,callback);\n\n\tModel.find({},function(error,docs){\n\n   \t&#x2F;&#x2F;若没有向find传递参数，默认的是显示所有文档\n\n\t});\n\n\tModel.find({ &quot;age&quot;: 28 }, function (error, docs) {\n\n \t if(error){\n\n    \tconsole.log(&quot;error :&quot; + error);\n\n \t }else{\n\n    \tconsole.log(docs); &#x2F;&#x2F;docs: age为28的所有文档\n\n\t}\n\n\t});\n</code></pre><h2>2.2model保存方法</h2>\n<pre class=\"prettyprint\"><code>Model.create(文档数据, callback))\n\n\tModel.create({ name:&quot;model\\_create&quot;, age:26}, function(error,doc){\n\n    \tif(error) {\n\n        \tconsole.log(error);\n\n    \t} else {\n\n        \tconsole.log(doc);\n\n    \t}\n\n\t});\n</code></pre><h2>2.3 entity保存方法</h2>\n<pre class=\"prettyprint\"><code>Entity.save(文档数据, callback))\n\n\tvar Entity = new Model({name:&quot;entity\\_save&quot;,age: 27});\n\n\tEntity.save(function(error,doc) {\n\n\t  if(error) {\n\n        \tconsole.log(error);\n\n    \t} else {\n\n        \tconsole.log(doc);\n\n    \t}\n\n\t});\n\nmodel调用的是create方法，entity调用的是save方法\n</code></pre><h2>2.4 数据更新</h2>\n<pre class=\"prettyprint\"><code>obj.update(查询条件,更新对象,callback);\n\n\tvar conditions = {name : &#x27;test\\_update&#x27;};\n\n\tvar update = {$set : { age : 16 }};\n\n\tTestModel.update(conditions, update, function(error){\n\n    \tif(error) {\n\n        \tconsole.log(error);\n\n    \t} else {\n\n        \tconsole.log(&#x27;Update success!&#x27;);\n\n    \t}\n\n\t});\n</code></pre><h2>2.5 删除数据</h2>\n<pre class=\"prettyprint\"><code>obj.remove(查询条件,callback);\n\n\tvar conditions = { name: &#x27;tom&#x27; };\n\n\tTestModel.remove(conditions, function(error){\n\n   \t if(error) {\n\n       \t console.log(error);\n\n    \t} else {\n\n        \tconsole.log(&#x27;Delete success!&#x27;);\n\n    \t}\n\n\t});\n</code></pre><h2>2.6 小结</h2>\n<ol>\n<li>\n<p>查询：find查询返回符合条件一个、多个或者空数组文档结果。</p>\n</li>\n<li>\n<p>保存：model调用create方法，entity调用的save方法。</p>\n</li>\n<li>\n<p>更新：obj.update(查询条件,更新对象,callback)，根据条件更新相关数据。</p>\n</li>\n<li>\n<p>删除：obj.remove(查询条件,callback)，根据条件删除相关数据。</p>\n</li>\n</ol>\n<h1>3 简单查询</h1>\n<h2>3.1 find过滤查询</h2>\n<p>属性过滤 find(Conditions,field,callback);</p>\n<p>field省略或为Null，则返回所有属性。</p>\n<pre class=\"prettyprint\"><code>\t&#x2F;&#x2F;返回只包含一个键值name、age的所有记录\n\n\tModel.find({},{name:1, age:1, \\_id:0}，function(err,docs){\n\n   \t&#x2F;&#x2F;docs 查询结果集\n\n\t})\n</code></pre><blockquote>\n<p>说明：我们只需要把显示的属性设置为大于零的数就可以，当然1是最好理解的，_id是默认返回，如果不要显示加上(&quot;_id&quot;:0)，但是，对其他不需要显示的属性且不是_id，如果设置为0的话将会抛异常或查询无果</p>\n</blockquote>\n<h2>3.2 小结</h2>\n<ol>\n<li>\n<p>find过滤查询 ：find查询时我们可以过滤返回结果所显示的属性个数。</p>\n</li>\n<li>\n<p>findOne查询 ：只返回符合条件的首条文档数据。</p>\n</li>\n<li>\n<p>findById查询：根据文档_id来查询文档。</p>\n</li>\n</ol>\n<h1>4.高级查询</h1>\n<h2>4.1 大于、小于</h2>\n<p>$gt(&gt;)、$lt(&lt;)、$lte(&lt;=)、$gte(&gt;=)</p>\n<p>示例：</p>\n<pre class=\"prettyprint\"><code>        Model.find({&quot;age&quot;:{&quot;$gt&quot;:18}},function(error,docs){\n\n          &#x2F;&#x2F;查询所有nage大于18的数据\n\n        });\n</code></pre><h2>4.2不等于</h2>\n<p>$ne(!=)</p>\n<p>示例：</p>\n<pre class=\"prettyprint\"><code>        Model.find({ age:{ $ne:24}},function(error,docs){\n\n                &#x2F;&#x2F;查询age不等于24的所有数据\n\n        });\n</code></pre><p><strong>$ne可以匹配单个值，也可以匹配不同类型的值。</strong></p>\n<h2>4.3 匹配</h2>\n<p>$in 包含、等于</p>\n<p>示例：</p>\n<pre class=\"prettyprint\"><code>        Model.find({ age:{ $in: 20}},function(error,docs){\n\n          &#x2F;&#x2F;查询age等于20的所有数据\n\n        });\n\n        Model.find({ age:{$in:[20,30]}},function(error,docs){\n\n         &#x2F;&#x2F;可以把多个值组织成一个数组\n\n        });\n</code></pre><h2>4.4 或者</h2>\n<p>$or</p>\n<p>示例：</p>\n<pre class=\"prettyprint\"><code>        Model.find({&quot;$or&quot;:[{&quot;name&quot;:&quot;yaya&quot;},{&quot;age&quot;:28}]},function(error,docs){\n\n         &#x2F;&#x2F;查询name为yaya或age为28的全部文档\n\n        });\n</code></pre><h2>4.5 存在</h2>\n<p>$exists</p>\n<p>示例：</p>\n<pre class=\"prettyprint\"><code>        Model.find({name: {$exists: true}},function(error,docs){\n\n         &#x2F;&#x2F;查询所有存在name属性的文档\n\n        });\n\n        Model.find({telephone: {$exists: false}},function(error,docs){\n\n         &#x2F;&#x2F;查询所有不存在telephone属性的文档\n\n        });\n</code></pre><h2>4.6 小结</h2>\n<ol>\n<li>\n<p>$gt(&gt;),$lt(&lt;),$lte(&lt;=),$gte(&gt;=)操作符：针对Number类型的查询具体超强的排除性。</p>\n</li>\n<li>\n<p>$ne(!=)操作符：相当于不等于、不包含，查询时可根据单个或多个属性进行结果排除。</p>\n</li>\n<li>\n<p>$in操作符：和$ne操作符用法相同，但意义相反。</p>\n</li>\n<li>\n<p>$or操作符：可查询多个条件，只要满足其中一个就可返回结果值。</p>\n</li>\n<li>\n<p>$exists操作符：主要用于判断某些属性是否存在。</p>\n</li>\n</ol>\n<h1>5.游标</h1>\n<h2>5.1 简介</h2>\n<p>数据库使用游标返回find的执行结果。客户端对游标的实现通常能够对最终结果进行有效的控制。可以限制结果的数量，略过部分结果，根据任意键按任意顺序的组合对结果进行各种排序，或者是执行其他一些强的操作。</p>\n<h2>5.2 limit函数的基本用法</h2>\n<p>限制数量：find(Conditions,fields,options,callback);</p>\n<pre class=\"prettyprint\"><code>        Model.find({},null,{limit:20},function(err,docs){\n\n                console.log(docs);\n\n        });\n</code></pre><h2>5.3 skip函数的基本用法</h2>\n<p>skip函数和limit类似，都是对返回结果数量进行操作，不同的是skip函数的功能是略过指定数量的匹配结果，返回余下的查询结果。</p>\n<p>示例：</p>\n<p>1.跳过数量：find(Conditions,fields,options,callback);</p>\n<pre class=\"prettyprint\"><code>Model.find({},null,{skip:4},function(err,docs){\n\n    console.log(docs);\n\n});\n</code></pre><p><strong>如果查询结果数量中少于4个的话，则不会返回任何结果。</strong></p>\n<h2>5.4 sort函数的基本用法</h2>\n<p>sort函数可以将查询结果数据进行排序操作，该函数的参数是一个或多个键/值对，键代表要排序的键名，值代表排序的方向，1是升序，-1是降序。</p>\n<p>1.结果排序：find(Conditions,fields,options,callback);</p>\n<pre class=\"prettyprint\"><code>        Model.find({},null,{sort:{age:-1}},function(err,docs){\n\n         &#x2F;&#x2F;查询所有数据，并按照age降序顺序返回数据docs\n\n        });\n</code></pre><h2>5.6 小结</h2>\n<ol>\n<li>\n<p>limit函数：限制返回结果的数量。</p>\n</li>\n<li>\n<p>skip函数：略过指定的返回结果数量。</p>\n</li>\n<li>\n<p>sort函数：对返回结果进行有效排序。</p>\n</li>\n</ol>\n<h1>6 属性方法</h1>\n<h2>6.1 实例方法</h2>\n<p>有的时候，我们创造的Schema不仅要为后面的Model和Entity提供公共的属性，还要提供公共的方法.那怎么在Schema下创建一个实例方法呢，请看示例：</p>\n<pre class=\"prettyprint\"><code>        var mongoose = require(&#x27;mongoose&#x27;);\n\n        var saySchema = new mongoose.Schema({name : String});\n\n        saySchema.method(&#x27;say&#x27;, function () {\n\n         console.log(&#x27;Trouble Is A Friend&#x27;);\n\n        })\n\n        var say = mongoose.model(&#x27;say&#x27;, saySchema);\n\n        var lenka = new say();\n\n        lenka.say(); &#x2F;&#x2F;Trouble Is A Friend\n</code></pre><h2>6.2 Schema静态方法</h2>\n<p>示例：</p>\n<pre class=\"prettyprint\"><code>        var mongoose = require(&quot;mongoose&quot;);\n\n        var db = mongoose.connect(&quot;mongodb:&#x2F;&#x2F;127.0.0.1:27017&#x2F;test&quot;);\n\n        var TestSchema = new mongoose.Schema({\n\n                name : { type:String },\n\n                age  : { type:Number, default:0 },\n\n                email: { type:String, default:&quot;&quot; },\n\n                time : { type:Date, default:Date.now }\n\n        });\n\n        TestSchema.static(&#x27;findByName&#x27;, function (name, callback) {\n\n                return this.find({ name: name }, callback);\n\n        });\n\n        var TestModel = db.model(&quot;test1&quot;, TestSchema );\n\n        TestModel.findByName(&#x27;tom&#x27;, function (err, docs) {\n\n        &#x2F;&#x2F;docs所有名字叫tom的文档结果集\n\n        });\n</code></pre><h2>6.3 Schema追加方法</h2>\n<p>为Schema模型追加speak方法</p>\n<p>示例：</p>\n<pre class=\"prettyprint\"><code>        var mongoose = require(&quot;mongoose&quot;);\n\n        var db = mongoose.connect(&quot;mongodb:&#x2F;&#x2F;127.0.0.1:27017&#x2F;test&quot;);\n\n        var TestSchema = new mongoose.Schema({\n\n                name : { type:String },\n\n                age  : { type:Number, default:0 },\n\n                email: { type:String, default:&quot;&quot; },\n\n                time : { type:Date, default:Date.now }\n\n        });\n\n        TestSchema.methods.speak = function(){\n\n         console.log(&#x27;我的名字叫&#x27;+this.name);\n\n        }\n\n        var TestModel = db.model(&#x27;test1&#x27;,TestSchema);\n\n        var TestEntity = new TestModel({name:&#x27;Lenka&#x27;});\n\n        TestEntity.speak();&#x2F;&#x2F;我的名字叫Lenka\n</code></pre><blockquote>\n<p>强力推荐：<a href=\"http://www.hubwiz.com/\">汇智网</a></p>\n</blockquote>\n</div>",
      "title": "Mongoose快速入门",
      "last_reply_at": "2018-03-05T06:04:50.029Z",
      "good": false,
      "top": false,
      "reply_count": 12,
      "visit_count": 1975,
      "create_at": "2017-07-06T02:05:09.647Z",
      "author": {
        "loginname": "18820227745",
        "avatar_url": "https://avatars0.githubusercontent.com/u/25097125?v=4&s=120"
      }
    },
    {
      "id": "5a9cda222ffb8598445aeb59",
      "author_id": "5a9c01b78edf56a34493704f",
      "tab": "share",
      "content": "<div class=\"markdown-text\"><p>test01test01test01test01test01test01test01test01test01test01test01test01test01test01test01</p>\n</div>",
      "title": "testtest",
      "last_reply_at": "2018-03-05T05:48:18.903Z",
      "good": false,
      "top": false,
      "reply_count": 0,
      "visit_count": 95,
      "create_at": "2018-03-05T05:48:18.903Z",
      "author": {
        "loginname": "webhj",
        "avatar_url": "https://avatars0.githubusercontent.com/u/19943597?v=4&s=120"
      }
    },
    {
      "id": "5a9cd85377dc4e0d2136adfd",
      "author_id": "580c1addc3fead57507172a9",
      "tab": "ask",
      "content": "<div class=\"markdown-text\"><p>需要接受到前端上传的文件或者图片 koa2中要怎么做呢？</p>\n</div>",
      "title": "koa2文件上传怎么做呢？",
      "last_reply_at": "2018-03-05T05:40:35.337Z",
      "good": false,
      "top": false,
      "reply_count": 0,
      "visit_count": 106,
      "create_at": "2018-03-05T05:40:35.337Z",
      "author": {
        "loginname": "jowang2016",
        "avatar_url": "https://avatars1.githubusercontent.com/u/18169317?v=4&s=120"
      }
    },
    {
      "id": "5a9317d38d6e16e56bb808d1",
      "author_id": "5909444b782dbc4b183ecfe2",
      "tab": "share",
      "content": "<div class=\"markdown-text\"><p>也就前两天，面试大厂，其中有那么一个问题:</p>\n<ol>\n<li>你了解过Babel吗？</li>\n</ol>\n<blockquote>\n<p>了解过抽象语法树，又称AST，有学习过，也写过一个基于AST的<a href=\"https://github.com/axetroy/pag\">乞丐版模板引擎</a>，先是词法解析token，然后生产抽象语法树，然后更改抽象语法树，当然这是插件做的事情，最后根据新的AST生成代码。</p>\n</blockquote>\n<ol>\n<li>写过Babel插件吗</li>\n</ol>\n<blockquote>\n<p>没有，只是看过相关文档</p>\n</blockquote>\n<ol>\n<li>如果让你写一个插件，你能写的出来吗?</li>\n</ol>\n<blockquote>\n<p>应该可以吧…</p>\n</blockquote>\n<p>遂卒…</p>\n<p>开玩笑的，既然提到了，又没回答上来什么，哎哟我这暴脾气，一想到今晚就睡不着，连夜把它撸了。</p>\n<p>那么我们来从零写个插件吧。</p>\n<p>写一个预计算简单表达式的插件</p>\n<h3>预览</h3>\n<p>Before:</p>\n<pre class=\"prettyprint language-javascript\"><code>const result = 1 + 2 + 3 + 4 + 5;\n</code></pre><p>After:</p>\n<pre class=\"prettyprint language-javascript\"><code>const result = 15;\n</code></pre><p>以上的例子可能大家不会经常遇到，因为傻x才会这么写，但是有可能你会这么写</p>\n<pre class=\"prettyprint language-javascript\"><code>setTimeout(function(){\n  &#x2F;&#x2F; do something\n}, 1000 * 2) &#x2F;&#x2F; 插件要做的事，就是把 1000 * 2 替换成 2000\n</code></pre><h3>前提条件</h3>\n<ul>\n<li><a href=\"https://github.com/jamiebuilds/babel-handbook/blob/master/translations/zh-Hans/plugin-handbook.md\">Babel相关概念</a></li>\n</ul>\n<h3>开工</h3>\n<p>再写代码之前，你需要明白Babel它的原理，简单点说： <strong>Babel解析成AST，然后插件更改AST，最后由Babel输出代码</strong></p>\n<p>那么Babel的插件模块需要你暴露一个function，function内返回visitor</p>\n<pre class=\"prettyprint language-javascript\"><code>module.export = function(babel){\n  return {\n    visitor:{\n    }\n  }\n}\n</code></pre><p>visitor是对各类型的AST节点做处理的地方，那么我们怎么知道Babel生成了的AST有哪些节点呢？</p>\n<p>很简单，你可以把Babel转换的结果打印出来，或者这里有传送门: <a href=\"https://astexplorer.net/\">AST explorer</a></p>\n<p><img src=\"https://user-images.githubusercontent.com/9758711/36645536-6165e5c2-1aa5-11e8-8bd1-fad3e2080658.JPG\" alt=\"1\"></p>\n<p>这里我们看到 <code>const result = 1 + 2</code>中的<code>1 + 1</code>是一个<code>BinaryExpression</code>节点，那么在visitor中，我们就处理这个节点</p>\n<pre class=\"prettyprint language-javascript\"><code>var babel = require(&#x27;babel-core&#x27;);\nvar t = require(&#x27;babel-types&#x27;);\n\nconst visitor = {\n  BinaryExpression(path) {\n    const node = path.node;\n    let result;\n    &#x2F;&#x2F; 判断表达式两边，是否都是数字\n    if (t.isNumericLiteral(node.left) &amp;&amp; t.isNumericLiteral(node.right)) {\n      &#x2F;&#x2F; 根据不同的操作符作运算\n      switch (node.operator) {\n        case &quot;+&quot;:\n          result = node.left.value + node.right.value;\n          break\n        case &quot;-&quot;:\n          result = node.left.value - node.right.value;\n          break;\n        case &quot;*&quot;:\n          result =  node.left.value * node.right.value;\n          break;\n        case &quot;&#x2F;&quot;:\n          result =  node.left.value &#x2F; node.right.value;\n          break;\n        case &quot;**&quot;:\n          let i = node.right.value;\n          while (--i) {\n            result = result || node.left.value;\n            result =  result * node.left.value;\n          }\n          break;\n        default:\n      }\n    }\n\n    &#x2F;&#x2F; 如果上面的运算有结果的话\n    if (result !== undefined) {\n      &#x2F;&#x2F; 把表达式节点替换成number字面量\n      path.replaceWith(t.numericLiteral(result));\n    }\n  }\n};\n\nmodule.exports = function (babel) {\n  return {\n    visitor\n  };\n}\n</code></pre><p>插件写好了，我们运行下插件试试</p>\n<pre class=\"prettyprint language-javascript\"><code>const babel = require(&quot;babel-core&quot;);\n\nconst result = babel.transform(&quot;const result = 1 + 2;&quot;,{\n  plugins:[\n    require(&quot;.&#x2F;index&quot;)\n  ]\n});\n\nconsole.log(result.code); &#x2F;&#x2F; const result = 3;\n</code></pre><p>与预期一致，那么转换 <code>const result = 1 + 2 + 3 + 4 + 5;</code>呢?</p>\n<p>结果是: <code>const result = 3 + 3 + 4 + 5;</code></p>\n<p>这就奇怪了，为什么只计算了<code>1 + 2</code>之后，就没有继续往下运算了?</p>\n<p>我们看一下这个表达式的AST树</p>\n<p><img src=\"https://user-images.githubusercontent.com/9758711/36645660-2bdd028a-1aa7-11e8-9131-c38c232ccb10.JPG\" alt=\"2\"></p>\n<p>你会发现Babel解析成表达式里面再嵌套表达式。</p>\n<pre class=\"prettyprint\"><code>表达式( 表达式( 表达式( 表达式(1 + 2) + 3) + 4) + 5)\n</code></pre><p>而我们的判断条件并不符合所有的，只符合<code>1 + 2</code></p>\n<pre class=\"prettyprint language-javascript\"><code>    &#x2F;&#x2F; 判断表达式两边，是否都是数字\n    if (t.isNumericLiteral(node.left) &amp;&amp; t.isNumericLiteral(node.right)) {}\n</code></pre><p>那么我们得改一改</p>\n<p>第一次计算<code>1 + 2</code>之后，我们会得到这样的表达式</p>\n<pre class=\"prettyprint\"><code>表达式( 表达式( 表达式(3 + 3) + 4) + 5)\n</code></pre><p>其中 <code>3 + 3</code>又符合了我们的条件， 我们通过向上递归的方式遍历父级节点</p>\n<p>又转换成这样:</p>\n<pre class=\"prettyprint\"><code>表达式( 表达式(6 + 4) + 5)\n表达式(10 + 5)\n15\n</code></pre><pre class=\"prettyprint language-javascript\"><code>    &#x2F;&#x2F; 如果上面的运算有结果的话\n    if (result !== undefined) {\n      &#x2F;&#x2F; 把表达式节点替换成number字面量\n      path.replaceWith(t.numericLiteral(result));\n\n      let parentPath = path.parentPath;\n\n      &#x2F;&#x2F; 向上遍历父级节点\n      parentPath &amp;&amp; visitor.BinaryExpression.call(this, parentPath);\n    }\n</code></pre><p>到这里，我们就得出了结果 <code>const result = 15;</code></p>\n<p>那么其他运算呢:</p>\n<p><code>const result = 100 + 10 - 50</code> &gt;&gt;&gt; <code>const result = 60;</code></p>\n<p><code>const result = (100 / 2) + 50</code> &gt;&gt;&gt; <code>const result = 100;</code></p>\n<p><code>const result = (((100 / 2) + 50 * 2) / 50) ** 2</code> &gt;&gt;&gt; <code>const result = 9;</code></p>\n<h3>完结</h3>\n<p>到这里，已经向你大概的讲解了，如何编写一个Babel插件，再也不怕面试官问我答不出什么了哈…</p>\n<p>你以为这就完了吗?</p>\n<p>并没有</p>\n<p>如果转换这样呢: <code>const result = 0.1 + 0.2;</code></p>\n<p>预期肯定是<code>0.3</code>, 但是实际上，Javascript有浮点计算误差，得出的结果是<code>0.30000000000000004</code></p>\n<p>那是不是这个插件就没卵用？</p>\n<p>这就需要你去矫正浮点运算误差了，可以使用<a href=\"https://github.com/MikeMcl/big.js\">Big.js</a>;</p>\n<p>比如: <code>result = node.left.value + node.right.value;</code> 改成 <code>result = +new Big(node.left.value).plus(node.right.value);</code></p>\n<p>你以为完了吗? 这个插件还可以做很多</p>\n<p>比如: <code>Math.PI * 2</code> &gt;&gt;&gt; <code>6.283185307179586</code></p>\n<p>比如: <code>Math.pow(2, 2)</code> &gt;&gt;&gt; <code>4</code></p>\n<p>…</p>\n<p>…</p>\n<p>最后上项目地址: <a href=\"https://github.com/axetroy/babel-plugin-pre-calculate-number\">https://github.com/axetroy/babel-plugin-pre-calculate-number</a></p>\n</div>",
      "title": "面试官: 你了解过Babel吗？写过Babel插件吗? 答: 没有。卒",
      "last_reply_at": "2018-03-05T05:38:43.203Z",
      "good": true,
      "top": false,
      "reply_count": 41,
      "visit_count": 2493,
      "create_at": "2018-02-25T20:08:51.322Z",
      "author": {
        "loginname": "axetroy",
        "avatar_url": "https://avatars2.githubusercontent.com/u/9758711?v=4&s=120"
      }
    }
  ]
}